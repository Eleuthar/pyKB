* Closures are an alternative to small classes, for hiding & encapsulating data.

* A true closure must have an outer scope function var to be referenced by the inner.

* "nonlocal" is used to store \ modify an outer scope immutable variable, excluding globals

* <new_function>.__closure__[0].cell_contents == closure variable value


# EXAMPLE 1
``````````````
def make_counter():
    i = 0
    def counter(): # counter() is a closure
        nonlocal i
        i += 1
        return i
    return counter

>>> c1 = make_counter()
>>> c2 = make_counter()
>>> print (c1(), c1(), c2(), c2())
1 2 1 2


# EXAMPLE 2
``````````````
def generateCallback(x, y):
    x = x
    y = y
    def callback(ch, method, properties, body):
        print(f'Executing callback with {x} {y}')
        print(f'Executing inner callback with {ch}, {method}, {properties} & {body}')
    return callback


>>> qb = generateCallback('xxx', 'qqq')
>>> qb.__closure__[0].cell_contents == 'xxx'
>>> qb.__closure__[1].cell_contents == 'qqq'
>>> qb('ch', 'method', 'properties', 'body')
Executing callback with xxx qqq
Executing inner callback with ch, method, properties & body



