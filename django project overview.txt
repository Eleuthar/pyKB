flow
```````````````
startproject
startapp
project\\settings.INSTALLED_APPS
<APP>\\apps.<APP>Config
<APP>\\apps.models
	def __str__()
register model in admin - optional
makemigrations
migrate
createsuperuser
define serializer & bond to model
define view function & 
import view in urls & append urlpatterns
<APP>\\templates\\<APP>\\<htmlPages>
POST \ PUT \ GET via Django DB API: .get, .save()
request.POST['keyName'] && HttpResponseRedirect(reverse("<app>:<url name>", args=(var,) ))
    \\ prevent data duplication on browser Back button




~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PROJECT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

urls
	from django.contrib import admin
	from django.urls import include, path
	from django.contrib.auth import views as auth_views
	from django.conf import settings
	from django.conf.urls.static import static
	from users import views as user_views
		
	if settings.DEBUG:
    	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
		
		
urls.urlpatterns
	path('admin/', admin.site.urls),
    path('profile/', user_views.profile, name='profile'),    
    path('', include('blog.urls')),
    path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),


settings.INSTALLED_APPS
	appX.apps.AppXConfig
	GRANT ALL PRIVILEGES ON *.* TO 'uzr'@'localhost'
	\\ globals
	LOGIN_REDIRECT, LOGIN_URL, EMAIL_*




~~~~~~~~~~~~~~~~~~~~~~~~~~~~ APP.MODELS.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	from django.db import models
	from django.contrib.auth.models import User

	class Profile(models.Model):
		user = models.OneToOneField(User, on_delete=models.CASCADE)
		image = models.ImageField(default='default.jpg', upload_to='profile_pics')
		def __str__(self):
			return f'{self.user.username} Profile'

	class Question(models.Model):
		question_text = models.CharField(max_length=200)
		pub_date = models.DateTimeField('<optional overriding col name>')
		def get_absolut_url(self):
			return reverse('post-detail', kwargs={'<urlParam>': self.urlParam})
		
	class Option(models.Model):
		question = models.ForeignKey(Question, on_delete=models.CASCADE)
		option_text	= models.CharField(max_length=200)
		votes = models.IntegerField(default=0)



~~~~~~~~~~~~~~~~~~~~~~~ APP.SERIALIZERS.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~

from rest_framework import serializers
from <APP>.models import <ClassModel>



~~~~~~~~~~~~~~~~~~~~~~~~~~ APP.URLS.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from django.urls import path
from . import views


urls.urlpatterns = [
	path('route', 'view_function', 'view_function_dict_kwargs', 'name'),	
	path('<int:pk>/results/, views.results, name='results'),	
	path('<int:pk>/results, views.ResultsView.as_view(), name='results')
]


~~~~~~~~~~~~~~~~~~~~~~~~~~ APP.ADMIN.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from django.contrib import admin
from .models import ClassName

admin.site.register(ClassName)
	


~~~~~~~~~~~~~~~~~~~~~~~~~~ APP.VIEWS.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from rest_framework.response import Response

# FUNCTION
from rest_framework.decorators import api_view

# CLASS
from django.views import generic

# DRF
from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.generics import \
	GenericAPIView \
	CreateAPIView \
	UpdateAPIView \
	RetrieveAPIView \
	ListAPIView \
	ListCreateAPIView
	DestroyAPIView \
	RetrieveUpdateDestroyAPIView \
	RetrieveDestroyAPIView \

"""
MRO:

	APIView < GenericAPIView < CRUD ModelMixin < CRUD APIView
	APIView < GenericAPIView < CRUD ModelMixin < ModelViewSet
	APIView < GenericAPIView < ViewSetMixin < GenericViewSet
	APIView < ViewSetMixin < ViewSet
	


from django.template import loader
from django.shortcuts import get_object_or_404, render
from django.http import HttpResponse, HttpResponseRedirect, Http404
from django.urls import reverse
from django.contrib.auth.decorators import login_required

from <APP>.serializers import <MODEL>Serializer
from <APP>.models import <MODEL>



\\ Http404
except ModelClassName.DoesNotExist:
	raise Http404('Item does not exist')

\\ loader
template = loader.get_template('appX/index.html')
return HttpResponse(template.render(content, request))

\\ get_object_or_404
question = get_object_or_404(Question, pk=request.POST['choice'])
return HttpResponseRedirect(reverse('appX:view_function_name'))
    # OR
question = get_object_or_404(Question, pk=question_id)
context = {'question': question}
return render(request, 'appX/detail.html', context)



# DRF APIView
`````````````````````````````````
class <Name>(APIView):

	def.get(self, request):
		obj = <MODEL>.objects.all()
		serializer = <MODEL>Serializer(obj, many=True)
		return Response(serializer.data)

	def.post(self, request, *args, **kwargs):
		if request.data.get('<prop>') != '':
		serializer = <MODEL>Serializer(data=request.data)
		if serializer.is_valid():
			serializer.save()
			return HttpResponseRedirect(reverse('appX:view_fun_name'))
	


# DRF Generics
```````````````````````````````````
"""
Exposes .get() & .post()
"""

class <Name>(ListCreateAPIView):
	# handles GET & POST
	queryset = <MODEL>.objects.all()
	serializer_class = <MODEL>.serializer


class <Name>(ListCreateAPIView):
	# handles GET & POST
	queryset = <MODEL>.objects.all()
	serializer_class = <MODEL>.serializer


class <Name>(RetrieveUpdateDestroyAPIView):
	# handles GET & PUT & DELETE 
	queryset = <MODEL>.objects.all()
	serializer_class = <MODEL>.serializer



# DRF ViewSets
```````````````````
"""
Exposes .list() for many items, .retrieve() for single item & .create()
Register viewset with router class
Bind view name to functions
"""


views.py:

	def list(self, request):
		queryset = <MODEL>.objects.all()
		serializer = <MODEL>Serializer(queryset, many=True)
		return Response(serializer.data)
	
	def retrieve(self, request, pk=None):
		queryset = <MODEL>.objects.all()
		if pk is not None:
			obj = get_object_or_404(queryset, pk=pk)
			serializer = <MODEL>Serializer(obj)
			return Response(serializer.data)


urls.py:
	
	<app view name> = <APP>ViewSets.as_view({
		'get': 'list'
	})

	<app view name> = <APP>ViewSets.as_view({
		'get': 'retrieve'
	})




# DJANGO Generic
```````````````````````````````````
class <Name>(generic.ListView):
        template_name = "<url path>"
        context_object_name = "<template key>"

        def get_queryset(self):
        	return Question.objects.order_by("-pub_date")[:5]
        
        
    class DetailView(generic.DetailView):
		model = Question
		template_name = "polls/detail.html"
		context_object_name = '<template object>'
		ordering = [-<key>]	

		\\ override template_name expected to be:
			 <app name>/<model name>_list.html
 			 <app name>/<model name>_detail.html
 			 
	 class PostCreateView(generic.CreateView):
	 	model = Post
	 	fields = ['title', 'content']
	 	
	 	\\ override
	 	def form_valid(self, form):
	 		form.instance.author = self.request.user
			return super().form_valid(form)




FUNCTION BASED VIEW
``````````````````````

# DRF
@api_view(['GET'], ['POST'])
def q_view(request):

	if request.method == 'GET':
		obj = <MODEL>.objects.all()
		serializer = <MODEL>Serializer(obj, many=True)
		return Response(serializer.data)

	elif request.method == 'POST':
		return Response(<JSON>)



~~~~~~~~~~~~~~~~~~~~~~~~~~ APP.FORMS.PY ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from django import forms
from django.contrib.auth.model import User
from django.contrib.auth.forms import UserCreationForm


class UserRegisterForm(UserCreationForm):

	email = forms.EmailField()
	
	\\ nested namespace for configurations in one place
	class Meta:
		model = User

		fields = ['username', 'email', 'password1', 'password2']
		# OR
		fields = '__ALL__'



~~~~~~~~~~~~~~~~~~~ APP/templates/APP/index.html ~~~~~~~~~~~~~~~~~~~~~~

\\ templates use context keys

\\ dynamic url:

    {% url '<url name>' <path variable> %}
	    OR	
	polls.urls.py.app_name = "<app name>"
    {% url '<app name>:<url name>' <path variable> %}



~~~~~~~~~~~~~~~~~~~~~~~~~~ ACTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

$ python manage.py check
	\\ Check for any problems without making migrations or touching the database


$ django-admin sqlmigrate appX 0001
	\\ Print the SQL for the named migration

	
$ python manage.py makemigrations
	\\ Display translation to SQL syntax stored under 'appX\\migrations' as 0001_initial.py. 
	\\ To run after each change in models.py. If approved, will be applied by <migrate> cmd.

			
$ python manage.py migrate
	\\ Apply changes in models.py;
	\\ Create tables if not yet existing, for apps in Project.settings.INSTALLED_APPS
	\\ naming: <appX>_<models.ClassName>; FK will be appended an ID


$ python manage.py shell:
	\\ each FK model ex. Question record corresponds to an "option_set" where the Question.pk == Option.fk
	\\ property is accessed with '__' instead of '.'

	from appX.models import ModelClassZ

	q = ModelClassZ()
	q.objects.all
	q.objects.filter(tableColumn=value)
	q.objects.get(tableColumn=value)
	
	z = Question.objects.get(pk=1)
	z.option_set.filter(option_text__contains="some regex")
	z.option_set.create(option_text="NEW QUESTION", votes=5)
	
	Option.objects.filter(question__pub_date__year=timezone.now().year)
	Option.objects.filter(question__question_text__startswith="some regex")
	q.save()



